# -*- coding: utf-8 -*-
"""SCOAP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-AF-uOyGsfi06tJ9_vHpASxjzjqfPqhX
"""

#!/usr/bin/env python3
"""
Fixed SCOAP with proper levelization algorithm from PDF
"""

import sys, re, math
from collections import defaultdict, deque

SUPPORTED_GATES = {
    "AND", "NAND", "OR", "NOR", "XOR", "XNOR", "INV", "BUF", "NOT"
}
SEQUENTIAL_GATES = {
    "DFF", "DFFR", "DFFS", "FD", "FD1", "FLIPFLOP", "DFFE", "DFF"
}

def verilog_to_netlist_lines(lines):
    inputs = []
    outputs = []
    gates = []
    seqs = []

    gate_map = {
        "and":"AND", "nand":"NAND", "or":"OR", "nor":"NOR",
        "xor":"XOR", "xnor":"XNOR", "not":"INV", "buf":"BUF"
    }
    seq_map = {
        "dff":"DFF", "dffr":"DFFR", "dffs":"DFFS",
        "fd":"DFF", "flop":"DFF", "dffe":"DFFE"
    }

    for raw in lines:
        line = raw.strip()
        if not line:
            continue
        line = re.sub(r"//.*", "", line).strip()
        if not line:
            continue
        line = re.sub(r";\s*$", "", line)

        m_in = re.search(r"\binput\b\s*([^;()\r\n]*)", line)
        if m_in:
            names = re.findall(r"[A-Za-z_]\w*", m_in.group(1))
            names = [n for n in names if n.lower() not in ("input","output")]
            inputs.extend(names)
            continue

        m_out = re.search(r"\boutput\b\s*([^;()\r\n]*)", line)
        if m_out:
            names = re.findall(r"[A-Za-z_]\w*", m_out.group(1))
            names = [n for n in names if n.lower() not in ("input","output")]
            outputs.extend(names)
            continue

        m = re.match(r"^(\w+)(?:\s+(\w+))?\s*\(\s*([^)]+)\s*\)\s*,?\s*$", line)
        if not m:
            continue
        gtype_raw, inst, ports_str = m.groups()
        gtype_l = gtype_raw.lower()
        ports = [p.strip() for p in ports_str.split(",") if p.strip()]
        if not ports:
            continue

        if gtype_l in gate_map:
            out = ports[0]
            ins = ports[1:]
            gates.append((inst if inst else f"{gtype_raw}_inst", out, ins, gate_map[gtype_l]))
            continue

        if gtype_l in seq_map:
            d = ports[0] if len(ports) > 0 else ""
            clk = ports[1] if len(ports) > 1 else ""
            q = ports[-1] if len(ports) > 0 else ""
            seqs.append((inst if inst else f"{gtype_raw}_inst", q, [d, clk], seq_map[gtype_l]))
            continue

    out_lines = []
    if inputs:
        out_lines.append(".inputs " + " ".join(sorted(dict.fromkeys(inputs))))
    else:
        out_lines.append(".inputs")
    if outputs:
        out_lines.append(".outputs " + " ".join(sorted(dict.fromkeys(outputs))))
    else:
        out_lines.append(".outputs")

    for inst, outn, ins, gtype in gates:
        out_lines.append(f"{inst} {outn} {' '.join(ins)} {gtype}")
    for inst, q, ins, gtype in seqs:
        d = ins[0] if ins else ""
        clk = ins[1] if len(ins) > 1 else ""
        out_lines.append(f"{inst} {q} {d} {clk} {gtype}")

    return out_lines

def parse_netlist(filename_or_lines):
    if isinstance(filename_or_lines, str):
        with open(filename_or_lines, "r") as f:
            raw_lines = [l.rstrip("\n") for l in f]
    else:
        raw_lines = list(filename_or_lines)

    inputs, outputs, gates, seq_cells = [], [], [], []
    for raw in raw_lines:
        line = raw.strip()
        if not line or line.startswith("#") or line.startswith("//"):
            continue
        if line.startswith(".inputs"):
            parts = line.split()
            inputs.extend(parts[1:])
            continue
        if line.startswith(".outputs"):
            parts = line.split()
            outputs.extend(parts[1:])
            continue
        parts = line.split()
        if len(parts) < 3:
            continue
        inst = parts[0]
        out_net = parts[1]
        in_nets = parts[2:-1]
        gtype = parts[-1].upper()
        if gtype in SUPPORTED_GATES:
            gates.append((inst, out_net, in_nets, gtype))
        elif gtype in SEQUENTIAL_GATES:
            seq_cells.append((inst, out_net, in_nets, gtype))
        else:
            print(f"Warning: unsupported gate type '{gtype}' on line: {line}", file=sys.stderr)
    return inputs, outputs, gates, seq_cells

def compute_levels(inputs, outputs, gates, seq_cells):
    """Implement levelization algorithm from PDF Page 7"""
    # Forward levels from PIs
    fwd_level = {}
    queue = deque()

    # Initialize PIs to level 0
    for pi in inputs:
        fwd_level[pi] = 0
        queue.append(pi)

    # Build fanout map
    fanout = defaultdict(list)
    for inst, out, ins, gtype in gates:
        for i in ins:
            fanout[i].append((out, 'comb'))
    for inst, q, ins, gtype in seq_cells:
        for i in ins:
            if i:  # D and CLK inputs
                fanout[i].append((q, 'seq'))

    # Forward levelization
    while queue:
        net = queue.popleft()
        current_level = fwd_level[net]

        for fanout_net, net_type in fanout.get(net, []):
            if fanout_net not in fwd_level:
                fwd_level[fanout_net] = current_level + 1
                queue.append(fanout_net)
            else:
                fwd_level[fanout_net] = max(fwd_level[fanout_net], current_level + 1)

    # Backward levels from POs
    bkwd_level = {}
    queue = deque()

    # Initialize POs to level 0
    for po in outputs:
        bkwd_level[po] = 0
        queue.append(po)

    # Build fanin map
    fanin = {}
    for inst, out, ins, gtype in gates:
        fanin[out] = ('comb', ins, gtype)
    for inst, q, ins, gtype in seq_cells:
        fanin[q] = ('seq', ins, gtype)

    # Backward levelization
    while queue:
        net = queue.popleft()
        current_level = bkwd_level[net]

        if net in fanin:
            net_type, inputs, gtype = fanin[net]
            for inp in inputs:
                if inp and inp not in bkwd_level:
                    bkwd_level[inp] = current_level + 1
                    queue.append(inp)
                elif inp:
                    bkwd_level[inp] = max(bkwd_level[inp], current_level + 1)

    return fwd_level, bkwd_level

def scoap_with_levelization(inputs, outputs, gates, seq_cells):
    CC0, CC1, CO = {}, {}, {}
    SC0, SC1, SO = {}, {}, {}

    # Compute levels
    fwd_level, bkwd_level = compute_levels(inputs, outputs, gates, seq_cells)

    # Initialize
    all_nets = set(list(fwd_level.keys()) + list(bkwd_level.keys()))
    for net in all_nets:
        CC0[net] = math.inf
        CC1[net] = math.inf
        CO[net] = math.inf
        SC0[net] = math.inf
        SC1[net] = math.inf
        SO[net] =  math.inf # Initialize SO to inf for sequential circuits

    # PIs have CC0=CC1=1, SC0=SC1=0
    for pi in inputs:
        CC0[pi] = 1.0
        CC1[pi] = 1.0
        SC0[pi] = 0.0
        SC1[pi] = 0.0

    # POs have CO=0, SO=0
    for po in outputs:
        CO[po] = 0.0
        SO[po] = 0.0

    # Build FF list
    ffs = []
    for inst, q_out, in_nets, gtype in seq_cells:
        d = in_nets[0] if len(in_nets) > 0 else None
        clk = in_nets[1] if len(in_nets) > 1 else None
        ffs.append((q_out, d, clk))

    # Process by forward levels for CONTROLLABILITY (CC and SC)
    max_fwd_level = max(fwd_level.values()) if fwd_level else 0
    for level in range(max_fwd_level + 1):
        # Process combinational gates - COMBINATIONAL CONTROLLABILITY
        for inst, out, ins, gtype in gates:
            if fwd_level.get(out, -1) != level:
                continue

            vals0 = [CC0.get(x, math.inf) for x in ins]
            vals1 = [CC1.get(x, math.inf) for x in ins]

            if gtype == "AND":
                CC0[out] = min(vals0) + 1
                CC1[out] = sum(vals1) + 1
            elif gtype == "NAND":
                CC0[out] = sum(vals1) + 1
                CC1[out] = min(vals0) + 1
            elif gtype == "OR":
                CC0[out] = sum(vals0) + 1
                CC1[out] = min(vals1) + 1
            elif gtype == "NOR":
                CC0[out] = min(vals1) + 1
                CC1[out] = sum(vals0) + 1
            elif gtype in ("INV", "NOT"):
                CC0[out] = vals1[0] + 1
                CC1[out] = vals0[0] + 1
            elif gtype == "BUF":
                CC0[out] = vals0[0] + 1
                CC1[out] = vals1[0] + 1

        # Process combinational gates - SEQUENTIAL CONTROLLABILITY (NO +1)
        for inst, out, ins, gtype in gates:
            if fwd_level.get(out, -1) != level:
                continue

            vals0 = [SC0.get(x, math.inf) for x in ins]
            vals1 = [SC1.get(x, math.inf) for x in ins]

            if gtype == "AND":
                SC0[out] = min(vals0)  # NO +1
                SC1[out] = sum(vals1)  # NO +1
            elif gtype == "NAND":
                SC0[out] = sum(vals1)  # NO +1
                SC1[out] = min(vals0)  # NO +1
            elif gtype == "OR":
                SC0[out] = sum(vals0)  # NO +1
                SC1[out] = min(vals1)  # NO +1
            elif gtype == "NOR":
                SC0[out] = min(vals1)  # NO +1
                SC1[out] = sum(vals0)  # NO +1
            elif gtype in ("INV", "NOT"):
                SC0[out] = vals1[0]    # NO +1
                SC1[out] = vals0[0]    # NO +1
            elif gtype == "BUF":
                SC0[out] = vals0[0]    # NO +1
                SC1[out] = vals1[0]    # NO +1

        # Process sequential elements
        for q, d, clk in ffs:
            if fwd_level.get(q, -1) != level:
                continue

            if d and clk:
                # CC1(Q) = CC1(D) + CC1(C) + CCO(C) + CCO(RESET)
                CC1[q] = CC1.get(d, math.inf) + CC1.get(clk, math.inf) + CC0.get(clk, math.inf)
                # CC0(Q) = CC0(D) + CC1(C) + CCO(C) + CCO(RESET)
                CC0[q] = CC0.get(d, math.inf) + CC1.get(clk, math.inf) + CC0.get(clk, math.inf)

                # SC1(Q) = SC1(D) + SC1(C) + SCO(C) + SCO(RESET) + 1
                SC1[q] = SC1.get(d, math.inf) + SC1.get(clk, math.inf) + SC0.get(clk, math.inf) + 1
                # SC0(Q) = SC0(D) + SC1(C) + SCO(C) + SCO(RESET) + 1
                SC0[q] = SC0.get(d, math.inf) + SC1.get(clk, math.inf) + SC0.get(clk, math.inf) + 1

    # ==================== SO CALCULATION FOR SEQUENTIAL CIRCUITS ====================

    # ==================== SO CALCULATION FOR SEQUENTIAL CIRCUITS ====================

    # Process by backward levels for OBSERVABILITY
    max_bkwd_level = max(bkwd_level.values()) if bkwd_level else 0
    for level in range(max_bkwd_level + 1):
        # Process nets at this backward level
        for net in bkwd_level:
            if bkwd_level[net] != level:
                continue

            # If this is a gate output, propagate to inputs - SO through combinational
            for inst, out, ins, gtype in gates:
                if out == net:
                    so_out = SO.get(out, math.inf)
                    if not math.isfinite(so_out):
                        continue

                    for idx, inp in enumerate(ins):
                        # Calculate the cost to set other inputs to non-controlling values
                        if gtype in ("AND", "NAND"):
                            # For AND/NAND: set other inputs to 1 (non-controlling for AND)
                            other_cost = sum([SC1.get(x, math.inf) for x in ins if x != inp])
                            new_so = so_out + other_cost  # NO +1 for sequential
                        elif gtype in ("OR", "NOR"):
                            # For OR/NOR: set other inputs to 0 (non-controlling for OR)
                            other_cost = sum([SC0.get(x, math.inf) for x in ins if x != inp])
                            new_so = so_out + other_cost  # NO +1 for sequential
                        elif gtype in ("XOR", "XNOR"):
                            # For XOR/XNOR: either all 0 or all 1
                            cost0 = sum([SC0.get(x, math.inf) for x in ins if x != inp])
                            cost1 = sum([SC1.get(x, math.inf) for x in ins if x != inp])
                            other_cost = min(cost0, cost1)
                            new_so = so_out + other_cost  # NO +1 for sequential
                        else:  # BUF, INV, NOT
                            new_so = so_out  # NO +1 for sequential

                        if new_so < SO.get(inp, math.inf):
                            SO[inp] = new_so

            # If this is a FF output, propagate to inputs - SO gets +1 when crossing FF backward
            for q, d, clk in ffs:
                if q == net:
                    so_q = SO.get(q, math.inf)
                    if not math.isfinite(so_q):
                        continue

                    # SO(D) = SO(Q) + SC1(C) + SCO(C) + SCO(RESET) + 1
                    if d:
                        new_so_d = so_q + SC1.get(clk, math.inf) + SC0.get(clk, math.inf) + 1
                        if new_so_d < SO.get(d, math.inf):
                            SO[d] = new_so_d

                    # Clock observability - SO gets +1
                    if clk:
                        # SO(C) - ONLY OPTION 1 + WITH +1
                        if all(math.isfinite(x) for x in [SC1.get(q, math.inf), SC0.get(d, math.inf), SC1.get(clk, math.inf), SC0.get(clk, math.inf)]):
                            new_so_clk = so_q + SC1.get(q, math.inf) + SC0.get(d, math.inf) + SC1.get(clk, math.inf) + SC0.get(clk, math.inf) + 1
                            if new_so_clk < SO.get(clk, math.inf):
                                SO[clk] = new_so_clk

    # ==================== CO CALCULATION (for both combinational and sequential) ====================

    # Process by backward levels for COMBINATIONAL OBSERVABILITY
    max_bkwd_level = max(bkwd_level.values()) if bkwd_level else 0
    for level in range(max_bkwd_level + 1):
        for net in bkwd_level:
            if bkwd_level[net] != level:
                continue

            # If this is a gate output, propagate to inputs - CO through combinational gets +1
            for inst, out, ins, gtype in gates:
                if out == net:
                    co_out = CO.get(out, math.inf)

                    for idx, inp in enumerate(ins):
                        if gtype in ("AND", "NAND"):
                            other_cost = sum([CC1.get(x, math.inf) for x in ins if x != inp])
                            CO[inp] = min(CO.get(inp, math.inf), co_out + other_cost + 1)  # +1 for combinational
                        elif gtype in ("OR", "NOR"):
                            other_cost = sum([CC0.get(x, math.inf) for x in ins if x != inp])
                            CO[inp] = min(CO.get(inp, math.inf), co_out + other_cost + 1)  # +1 for combinational
                        else:  # BUF, INV, etc.
                            CO[inp] = min(CO.get(inp, math.inf), co_out + 1)  # +1 for combinational

            # If this is a FF output, propagate to inputs - CO through FF gets NO +1
            for q, d, clk in ffs:
                if q == net:
                    co_q = CO.get(q, math.inf)

                    # CO(D) = CO(Q) + CC1(C) + CCO(C) + CCO(RESET)  [NO +1]
                    if d:
                        CO[d] = min(CO.get(d, math.inf), co_q + CC1.get(clk, math.inf) + CC0.get(clk, math.inf))  # NO +1

                    # Clock observability - CO gets NO +1
                    if clk:
                        # CO(C) - ONLY OPTION 1 [NO +1]
                        if all(math.isfinite(x) for x in [co_q, CC1.get(q, math.inf), CC0.get(d, math.inf), CC1.get(clk, math.inf), CC0.get(clk, math.inf)]):
                            CO[clk] = min(CO.get(clk, math.inf),
                                          co_q + CC1.get(q, math.inf) + CC0.get(d, math.inf) + CC1.get(clk, math.inf) + CC0.get(clk, math.inf))  # NO +1

    return CC0, CC1, CO, SC0, SC1, SO, fwd_level, bkwd_level

def main():
    default_filename = "combined_seq.v"

    if len(sys.argv) > 1 and sys.argv[1] != '-f':
        inpath = sys.argv[1]
    elif default_filename:
        inpath = default_filename
        print(f"Using default: {inpath}")
    else:
        print("Usage: python3 scoap_tool.py <file.v | netlist.txt>")
        sys.exit(1)

    if inpath.lower().endswith(".v") or inpath.lower().endswith(".sv"):
        with open(inpath, "r") as f:
            vlines = f.readlines()
        netlist_lines = verilog_to_netlist_lines(vlines)
    else:
        with open(inpath, "r") as f:
            netlist_lines = [l.rstrip("\n") for l in f]

    inputs, outputs, gates, seq_cells = parse_netlist(netlist_lines)

    # Filter inputs
    ff_qs = [q for (_, q, _, _) in seq_cells]
    driven_nets = [out for (_, out, _, _) in gates]
    inputs = [x for x in inputs if x not in outputs and x not in ff_qs and x not in driven_nets]

    CC0, CC1, CO, SC0, SC1, SO, fwd_level, bkwd_level = scoap_with_levelization(inputs, outputs, gates, seq_cells)

    print(f"\nâœ… SCOAP Results for {inpath}")
    print(f"{'Net':<10} {'FwdLev':<8} {'BkwdLev':<8} {'CC0':<8} {'CC1':<8} {'CO':<8} {'SC0':<8} {'SC1':<8} {'SO':<8}")
    print("-" * 85)

    all_nets = sorted(set(list(CC0.keys()) + list(CO.keys())))

    for n in all_nets:
        c0 = CC0.get(n, math.inf)
        c1 = CC1.get(n, math.inf)
        co = CO.get(n, math.inf)
        s0 = SC0.get(n, math.inf)
        s1 = SC1.get(n, math.inf)
        so = SO.get(n, math.inf)
        flev = fwd_level.get(n, "")
        blev = bkwd_level.get(n, "")

        c0s = f"{c0:.1f}" if math.isfinite(c0) else "inf"
        c1s = f"{c1:.1f}" if math.isfinite(c1) else "inf"
        cos = f"{co:.1f}" if math.isfinite(co) else "inf"
        s0s = f"{s0:.1f}" if math.isfinite(s0) else "inf"
        s1s = f"{s1:.1f}" if math.isfinite(s1) else "inf"
        sos = f"{so:.1f}" if math.isfinite(so) else "inf"
        flevs = f"{flev}" if flev != "" else "-"
        blews = f"{blev}" if blev != "" else "-"

        print(f"{n:<10} {flevs:<8} {blews:<8} {c0s:<8} {c1s:<8} {cos:<8} {s0s:<8} {s1s:<8} {sos:<8}")

if __name__ == "__main__":
    main()

this is the code for a scoap implementation. give me the index.html and web.css files for a website hosted on github that can run this code taking as input the verilog file and generating the output
